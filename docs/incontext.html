<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>incontext API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>incontext</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3 -u
#
# Copyright (c) 2016-2021 InSeven Limited
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import collections
import copy
import glob
import logging
import os
import sys

import paths
import utils

verbose = &#39;--verbose&#39; in sys.argv[1:] or &#39;-v&#39; in sys.argv[1:]
logging.basicConfig(level=logging.DEBUG if verbose else logging.INFO, format=&#34;[%(levelname)s] %(message)s&#34;)

PLUGIN_TYPE_CONTEXT_FUNCTION = &#34;context_function&#34;
PLUGIN_TYPE_COMMAND = &#34;command&#34;

CALLBACK_TYPE_SETUP = &#34;setup&#34;
CALLBACK_TYPE_STANDALONE = &#34;standalone&#34;


class _CommandPlugin(object):

    def __init__(self, name, help, callback, callback_type, arguments=[]):
        self.name = name
        self.help = help
        self.callback = callback
        self.callback_type = callback_type
        self.arguments = arguments
        self._runner = None

    def configure(self, incontext, parser):
        if self.callback_type == CALLBACK_TYPE_SETUP:
            self._runner = self.callback(incontext, parser)
            return self._runner
        elif self.callback_type == CALLBACK_TYPE_STANDALONE:
            for argument in self.arguments:
                parser.add_argument(*(argument.args), **(argument.kwargs))
            def callback(options):
                return self.callback(incontext, options)
            self._runner = callback
            return callback
        raise AssertionError(&#34;Unknown command callback type.&#34;)

    def run(self, **kwargs):
        return self._runner(Namespace(**kwargs))


class Argument(object):

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs


class _Plugins(object):
    &#34;&#34;&#34;
    Centralised mechanism for storing references to plugins by type.

    InContext allows for plugins to be registered either module-wide (via to `incontext` decorators), or by providing
    an implementation of the `initialize_plugin` function and registering plugins directly with the `InContext`
    instance passed in. In both of these situations, registered plugins are stored in an instance of the `_Plugins` class.

    Instances of the `incontext` have a module-scoped instance of `_Plugins` (`incontext._PLUGINS`) which is added to the
    runtime instance using the `extend` method when plugins are loaded.
    &#34;&#34;&#34;

    def __init__(self):
        self._plugins_by_type = collections.defaultdict(dict)

    def add_plugin(self, plugin_type, name, plugin):
        self._plugins_by_type[plugin_type][name] = plugin

    def plugin_types():
        return self._plugins_by_type.values()

    def plugins(self, plugin_type):
        return self._plugins_by_type[plugin_type]

    def plugin(self, plugin_type, name):
        return self._plugins_by_type[plugin_type][name]

    def extend(self, plugins):
        &#34;&#34;&#34;
        Add all of the plugins in `plugins` (type `_Plugins`) to the current instance.
        &#34;&#34;&#34;
        for plugin_type, plugin_plugins in plugins._plugins_by_type.items():
            for name, plugin in plugin_plugins.items():
                self.add_plugin(plugin_type, name, plugin)


_PLUGINS = _Plugins()
&#34;&#34;&#34;
Module-scoped plugin instances (used with decorator-based plugin registration).

Should not be manipulated directly.
&#34;&#34;&#34;


def context_function(name=None):
    &#34;&#34;&#34;
    Register a new Jinja context function, to be made available at template render as `name`.

    If `name` is not specified, the function name is used.
    &#34;&#34;&#34;
    def decorator(f):
        _PLUGINS.add_plugin(PLUGIN_TYPE_CONTEXT_FUNCTION, name if name is not None else f.__name__, f)
        return f
    return decorator


def command(name, help=None, arguments=[]):
    &#34;&#34;&#34;
    Register a new command.
    &#34;&#34;&#34;
    def decorator(f):
        _PLUGINS.add_plugin(PLUGIN_TYPE_COMMAND, name, _CommandPlugin(name=name,
                                                                      help=help,
                                                                      callback=f,
                                                                      callback_type=CALLBACK_TYPE_STANDALONE,
                                                                      arguments=arguments))
        return f
    return decorator


class Configuration(object):

    def __init__(self):
        self._values = {}

    def add(self, name, value):
        self._values[name] = value

    def __getattr__(self, name):
        return self._values[name]


class Namespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)


class InContext(object):

    def __init__(self, plugins_directory):
        &#34;&#34;&#34;
        Create a new InContext instance.

        @param plugins_directory: Path to the plugins directory.
        @type plugins_directory: str
        &#34;&#34;&#34;
        self.handlers = {}
        self.tasks = {}
        self.environment = {}
        self.arguments = []
        self.configuration_providers = {}
        self.configuration = Configuration()
        self._plugins = copy.deepcopy(_PLUGINS)
        self._loaded_plugin_directories = {}

        # Load and initialize the plugins.
        self.load_plugins(os.path.abspath(plugins_directory))

    def load_plugins(self, directory):
        &#34;&#34;&#34;
        Load and initialize the plugins in a given directory, adding them to the incontext instance.
        &#34;&#34;&#34;
        directory = os.path.abspath(directory)
        if directory in self._loaded_plugin_directories:
            return
        self._loaded_plugin_directories[directory] = True
        plugins = utils.load_plugins(directory)
        for plugin_name, plugin_instance in plugins.items():

            # Load the classic method-based plugins.
            if hasattr(plugin_instance, &#39;initialize_plugin&#39;):
                logging.debug(&#34;Initializing legacy plugin &#39;%s&#39;...&#34;, plugin_name)
                plugin_instance.initialize_plugin(self)

            # Load the decorator-based plugins by copying in their &#39;global&#39; state.
            if hasattr(plugin_instance, &#39;incontext&#39;):
                logging.debug(&#34;Initializing plugin &#39;%s&#39;...&#34;, plugin_name)
                self._plugins.extend(plugin_instance.incontext._PLUGINS)

    @property
    def commands(self):
        return self._plugins.plugins(PLUGIN_TYPE_COMMAND)

    @property
    def context_functions(self):
        &#34;&#34;&#34;
        Return a dictionary of additional context functions that will be available to the Jinja templating at render time.
        &#34;&#34;&#34;
        return self._plugins.plugins(PLUGIN_TYPE_CONTEXT_FUNCTION)

    def add_plugin(self, domain, name, plugin):
        &#34;&#34;&#34;
        Add a plugin, `plugin`, named `name`, in the specified domain, `domain`.

        This is the generic mechanism by which plugins are able to themselves add extension points to InContext. For
        example, the image handling plugin makes use of this to allow other plugins to register custom transforms.
        &#34;&#34;&#34;
        self._plugins.add_plugin(plugin_type=domain, name=name, plugin=plugin)

    def plugin(self, domain, name):
        &#34;&#34;&#34;
        Get the plugin `name` in the domain, `domain`.
        &#34;&#34;&#34;
        return self._plugins.plugin(plugin_type=domain, name=name)

    def plugins(self, domain):
        &#34;&#34;&#34;
        Return a dictionary of all plugins in a specific domain, keyed by their name.
        &#34;&#34;&#34;
        return self._plugins.plugins(plugin_type=domain)

    def add_argument(self, *args, **kwargs):
        &#34;&#34;&#34;
        Add a global command-line argument.

        Primarily intended to be used by configuration providers to allow them to specify a path to a configuration
        file, or configuration override.
        &#34;&#34;&#34;
        self.arguments.append(Argument(*args, **kwargs))

    def add_command(self, name, function, help=&#34;&#34;):
        &#34;&#34;&#34;
        Register a new command line command.

        The callable, function, will be called with the `argparse.ArgumentParser` sub-parser instance for that command as
        the first argument to allow the command to register any command-line arguments it requires. The command function
        must return a new callable which will be called if the the command is selected from the command line.

        @param name: The command identifier.
        @type name: str
        @param function: The function to be called to perform the registration.
        @type function: callable
        @param help: The help string that describes the command to be printed when the user passes the &#39;--help&#39; flag.
        @type help: str
        &#34;&#34;&#34;
        self._plugins.add_plugin(PLUGIN_TYPE_COMMAND, name, _CommandPlugin(name=name,
                                                                           help=help,
                                                                           callback=function,
                                                                           callback_type=CALLBACK_TYPE_SETUP))

    def add_configuration_provider(self, name, function):
        &#34;&#34;&#34;
        Add a named configuration provider.
        &#34;&#34;&#34;
        self.configuration_providers[name] = function

    def add_task(self, name, function):
        if name in self.tasks:
            raise AssertionError(&#34;Task &#39;%s&#39; is already defined.&#34; % name)
        self.tasks[name] = function

    def get_task(self, name):
        &#34;&#34;&#34;
        Return the task associated with `name`.

        Raises `KeyError` if no task has been registered with `name`.
        &#34;&#34;&#34;
        return self.tasks[name]

    # TODO: Consider using the plugin architecture for registering handlers
    #       https://github.com/inseven/incontext/issues/110
    def add_handler(self, name, function):
        &#34;&#34;&#34;
        Register a new handler.

        @param name: The handler identifier.
        @type name: str
        @param function: The function to be called.
        @type function: callable
        &#34;&#34;&#34;
        if name in self.handlers:
            raise AssertionError(&#34;Handler &#39;%s&#39; is already defined.&#34; % name)
        self.handlers[name] = function

    def get_handler(self, name):
        &#34;&#34;&#34;
        Return the handler for a given name.

        @param name: The handler identifier.
        @type name: str

        @return: Handler for a given name.
        @rtype: callable
        &#34;&#34;&#34;
        return self.handlers[name]

    def parser(self, add_subparsers=True):
        &#34;&#34;&#34;
        Return a parser, configured with the currently loaded plugins.
        &#34;&#34;&#34;
        # Create the argument parser.
        parser = argparse.ArgumentParser(prog=&#34;incontext&#34;, add_help=False, description=&#34;Generate website.&#34;)
        parser.add_argument(&#39;--help&#39;, &#39;-h&#39;, default=False, action=&#39;store_true&#39;, help=&#34;show this help message and exit&#34;)
        parser.add_argument(&#39;--site&#39;, &#39;-s&#39;, default=os.getcwd(), help=&#34;path to the root of the site&#34;)
        parser.add_argument(&#39;--verbose&#39;, &#39;-v&#39;, action=&#39;store_true&#39;, default=False, help=&#34;show verbose output&#34;)
        parser.add_argument(&#39;--volume&#39;, action=&#39;append&#39;, help=&#34;mount an additional volume in the Docker container&#34;)

        # Add the top-level arguments.
        for argument in self.arguments:
            parser.add_argument(*(argument.args), **(argument.kwargs))

        # Prepare the commands for running (if requested).
        if add_subparsers:
            subparsers = parser.add_subparsers(help=&#34;command to run&#34;)
            for command_plugin in self._plugins.plugins(PLUGIN_TYPE_COMMAND).values():
                subparser = subparsers.add_parser(command_plugin.name, help=command_plugin.help)
                fn = command_plugin.configure(self, subparser)
                subparser.set_defaults(fn=fn)

        return parser

    def run(self, args=None):
        &#34;&#34;&#34;
        Parse the command line arguments and execute the requested command.
        &#34;&#34;&#34;

        # Parse the top-level arguments, ignoring unknown arguments.
        parser = self.parser(add_subparsers=False)
        options, unknown = parser.parse_known_args(args)

        # Check to see if there are any site-local plugins.
        plugins_directory = os.path.join(os.path.abspath(options.site), &#34;plugins&#34;)
        if os.path.exists(plugins_directory):
            logging.debug(&#34;Loading site plugins...&#34;)
            self.load_plugins(plugins_directory)

        # Re-parse the arguments, along with the sub-commands / sub-parsers.
        logging.debug(&#34;Re-processing arguments with sub-commands...&#34;)
        parser = self.parser()
        options = parser.parse_args(args)

        # Explicit handling of the help functionality.
        if options.help:
            parser.print_help()
            exit(1)

        # Handle the arguments, running the command if specified.
        for name, configuration_provider in self.configuration_providers.items():
            self.configuration.add(name, configuration_provider(self, options))
        if &#39;fn&#39; not in options:
            logging.error(&#34;No command specified.&#34;)
            exit(1)
        options.fn(options)


def main():
    &#34;&#34;&#34;
    Entry-point for the command line. Should not be called directly.
    &#34;&#34;&#34;
    instance = InContext(plugins_directory=paths.PLUGINS_DIR)
    instance.run(sys.argv[1:])


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="incontext.command"><code class="name flex">
<span>def <span class="ident">command</span></span>(<span>name, help=None, arguments=[])</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command(name, help=None, arguments=[]):
    &#34;&#34;&#34;
    Register a new command.
    &#34;&#34;&#34;
    def decorator(f):
        _PLUGINS.add_plugin(PLUGIN_TYPE_COMMAND, name, _CommandPlugin(name=name,
                                                                      help=help,
                                                                      callback=f,
                                                                      callback_type=CALLBACK_TYPE_STANDALONE,
                                                                      arguments=arguments))
        return f
    return decorator</code></pre>
</details>
</dd>
<dt id="incontext.context_function"><code class="name flex">
<span>def <span class="ident">context_function</span></span>(<span>name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new Jinja context function, to be made available at template render as <code>name</code>.</p>
<p>If <code>name</code> is not specified, the function name is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def context_function(name=None):
    &#34;&#34;&#34;
    Register a new Jinja context function, to be made available at template render as `name`.

    If `name` is not specified, the function name is used.
    &#34;&#34;&#34;
    def decorator(f):
        _PLUGINS.add_plugin(PLUGIN_TYPE_CONTEXT_FUNCTION, name if name is not None else f.__name__, f)
        return f
    return decorator</code></pre>
</details>
</dd>
<dt id="incontext.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Entry-point for the command line. Should not be called directly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Entry-point for the command line. Should not be called directly.
    &#34;&#34;&#34;
    instance = InContext(plugins_directory=paths.PLUGINS_DIR)
    instance.run(sys.argv[1:])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="incontext.Argument"><code class="flex name class">
<span>class <span class="ident">Argument</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Argument(object):

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs</code></pre>
</details>
</dd>
<dt id="incontext.Configuration"><code class="flex name class">
<span>class <span class="ident">Configuration</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configuration(object):

    def __init__(self):
        self._values = {}

    def add(self, name, value):
        self._values[name] = value

    def __getattr__(self, name):
        return self._values[name]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="incontext.Configuration.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, name, value):
    self._values[name] = value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="incontext.InContext"><code class="flex name class">
<span>class <span class="ident">InContext</span></span>
<span>(</span><span>plugins_directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new InContext instance.</p>
<p>@param plugins_directory: Path to the plugins directory.
@type plugins_directory: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InContext(object):

    def __init__(self, plugins_directory):
        &#34;&#34;&#34;
        Create a new InContext instance.

        @param plugins_directory: Path to the plugins directory.
        @type plugins_directory: str
        &#34;&#34;&#34;
        self.handlers = {}
        self.tasks = {}
        self.environment = {}
        self.arguments = []
        self.configuration_providers = {}
        self.configuration = Configuration()
        self._plugins = copy.deepcopy(_PLUGINS)
        self._loaded_plugin_directories = {}

        # Load and initialize the plugins.
        self.load_plugins(os.path.abspath(plugins_directory))

    def load_plugins(self, directory):
        &#34;&#34;&#34;
        Load and initialize the plugins in a given directory, adding them to the incontext instance.
        &#34;&#34;&#34;
        directory = os.path.abspath(directory)
        if directory in self._loaded_plugin_directories:
            return
        self._loaded_plugin_directories[directory] = True
        plugins = utils.load_plugins(directory)
        for plugin_name, plugin_instance in plugins.items():

            # Load the classic method-based plugins.
            if hasattr(plugin_instance, &#39;initialize_plugin&#39;):
                logging.debug(&#34;Initializing legacy plugin &#39;%s&#39;...&#34;, plugin_name)
                plugin_instance.initialize_plugin(self)

            # Load the decorator-based plugins by copying in their &#39;global&#39; state.
            if hasattr(plugin_instance, &#39;incontext&#39;):
                logging.debug(&#34;Initializing plugin &#39;%s&#39;...&#34;, plugin_name)
                self._plugins.extend(plugin_instance.incontext._PLUGINS)

    @property
    def commands(self):
        return self._plugins.plugins(PLUGIN_TYPE_COMMAND)

    @property
    def context_functions(self):
        &#34;&#34;&#34;
        Return a dictionary of additional context functions that will be available to the Jinja templating at render time.
        &#34;&#34;&#34;
        return self._plugins.plugins(PLUGIN_TYPE_CONTEXT_FUNCTION)

    def add_plugin(self, domain, name, plugin):
        &#34;&#34;&#34;
        Add a plugin, `plugin`, named `name`, in the specified domain, `domain`.

        This is the generic mechanism by which plugins are able to themselves add extension points to InContext. For
        example, the image handling plugin makes use of this to allow other plugins to register custom transforms.
        &#34;&#34;&#34;
        self._plugins.add_plugin(plugin_type=domain, name=name, plugin=plugin)

    def plugin(self, domain, name):
        &#34;&#34;&#34;
        Get the plugin `name` in the domain, `domain`.
        &#34;&#34;&#34;
        return self._plugins.plugin(plugin_type=domain, name=name)

    def plugins(self, domain):
        &#34;&#34;&#34;
        Return a dictionary of all plugins in a specific domain, keyed by their name.
        &#34;&#34;&#34;
        return self._plugins.plugins(plugin_type=domain)

    def add_argument(self, *args, **kwargs):
        &#34;&#34;&#34;
        Add a global command-line argument.

        Primarily intended to be used by configuration providers to allow them to specify a path to a configuration
        file, or configuration override.
        &#34;&#34;&#34;
        self.arguments.append(Argument(*args, **kwargs))

    def add_command(self, name, function, help=&#34;&#34;):
        &#34;&#34;&#34;
        Register a new command line command.

        The callable, function, will be called with the `argparse.ArgumentParser` sub-parser instance for that command as
        the first argument to allow the command to register any command-line arguments it requires. The command function
        must return a new callable which will be called if the the command is selected from the command line.

        @param name: The command identifier.
        @type name: str
        @param function: The function to be called to perform the registration.
        @type function: callable
        @param help: The help string that describes the command to be printed when the user passes the &#39;--help&#39; flag.
        @type help: str
        &#34;&#34;&#34;
        self._plugins.add_plugin(PLUGIN_TYPE_COMMAND, name, _CommandPlugin(name=name,
                                                                           help=help,
                                                                           callback=function,
                                                                           callback_type=CALLBACK_TYPE_SETUP))

    def add_configuration_provider(self, name, function):
        &#34;&#34;&#34;
        Add a named configuration provider.
        &#34;&#34;&#34;
        self.configuration_providers[name] = function

    def add_task(self, name, function):
        if name in self.tasks:
            raise AssertionError(&#34;Task &#39;%s&#39; is already defined.&#34; % name)
        self.tasks[name] = function

    def get_task(self, name):
        &#34;&#34;&#34;
        Return the task associated with `name`.

        Raises `KeyError` if no task has been registered with `name`.
        &#34;&#34;&#34;
        return self.tasks[name]

    # TODO: Consider using the plugin architecture for registering handlers
    #       https://github.com/inseven/incontext/issues/110
    def add_handler(self, name, function):
        &#34;&#34;&#34;
        Register a new handler.

        @param name: The handler identifier.
        @type name: str
        @param function: The function to be called.
        @type function: callable
        &#34;&#34;&#34;
        if name in self.handlers:
            raise AssertionError(&#34;Handler &#39;%s&#39; is already defined.&#34; % name)
        self.handlers[name] = function

    def get_handler(self, name):
        &#34;&#34;&#34;
        Return the handler for a given name.

        @param name: The handler identifier.
        @type name: str

        @return: Handler for a given name.
        @rtype: callable
        &#34;&#34;&#34;
        return self.handlers[name]

    def parser(self, add_subparsers=True):
        &#34;&#34;&#34;
        Return a parser, configured with the currently loaded plugins.
        &#34;&#34;&#34;
        # Create the argument parser.
        parser = argparse.ArgumentParser(prog=&#34;incontext&#34;, add_help=False, description=&#34;Generate website.&#34;)
        parser.add_argument(&#39;--help&#39;, &#39;-h&#39;, default=False, action=&#39;store_true&#39;, help=&#34;show this help message and exit&#34;)
        parser.add_argument(&#39;--site&#39;, &#39;-s&#39;, default=os.getcwd(), help=&#34;path to the root of the site&#34;)
        parser.add_argument(&#39;--verbose&#39;, &#39;-v&#39;, action=&#39;store_true&#39;, default=False, help=&#34;show verbose output&#34;)
        parser.add_argument(&#39;--volume&#39;, action=&#39;append&#39;, help=&#34;mount an additional volume in the Docker container&#34;)

        # Add the top-level arguments.
        for argument in self.arguments:
            parser.add_argument(*(argument.args), **(argument.kwargs))

        # Prepare the commands for running (if requested).
        if add_subparsers:
            subparsers = parser.add_subparsers(help=&#34;command to run&#34;)
            for command_plugin in self._plugins.plugins(PLUGIN_TYPE_COMMAND).values():
                subparser = subparsers.add_parser(command_plugin.name, help=command_plugin.help)
                fn = command_plugin.configure(self, subparser)
                subparser.set_defaults(fn=fn)

        return parser

    def run(self, args=None):
        &#34;&#34;&#34;
        Parse the command line arguments and execute the requested command.
        &#34;&#34;&#34;

        # Parse the top-level arguments, ignoring unknown arguments.
        parser = self.parser(add_subparsers=False)
        options, unknown = parser.parse_known_args(args)

        # Check to see if there are any site-local plugins.
        plugins_directory = os.path.join(os.path.abspath(options.site), &#34;plugins&#34;)
        if os.path.exists(plugins_directory):
            logging.debug(&#34;Loading site plugins...&#34;)
            self.load_plugins(plugins_directory)

        # Re-parse the arguments, along with the sub-commands / sub-parsers.
        logging.debug(&#34;Re-processing arguments with sub-commands...&#34;)
        parser = self.parser()
        options = parser.parse_args(args)

        # Explicit handling of the help functionality.
        if options.help:
            parser.print_help()
            exit(1)

        # Handle the arguments, running the command if specified.
        for name, configuration_provider in self.configuration_providers.items():
            self.configuration.add(name, configuration_provider(self, options))
        if &#39;fn&#39; not in options:
            logging.error(&#34;No command specified.&#34;)
            exit(1)
        options.fn(options)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="incontext.InContext.commands"><code class="name">var <span class="ident">commands</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def commands(self):
    return self._plugins.plugins(PLUGIN_TYPE_COMMAND)</code></pre>
</details>
</dd>
<dt id="incontext.InContext.context_functions"><code class="name">var <span class="ident">context_functions</span></code></dt>
<dd>
<div class="desc"><p>Return a dictionary of additional context functions that will be available to the Jinja templating at render time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context_functions(self):
    &#34;&#34;&#34;
    Return a dictionary of additional context functions that will be available to the Jinja templating at render time.
    &#34;&#34;&#34;
    return self._plugins.plugins(PLUGIN_TYPE_CONTEXT_FUNCTION)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="incontext.InContext.add_argument"><code class="name flex">
<span>def <span class="ident">add_argument</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a global command-line argument.</p>
<p>Primarily intended to be used by configuration providers to allow them to specify a path to a configuration
file, or configuration override.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_argument(self, *args, **kwargs):
    &#34;&#34;&#34;
    Add a global command-line argument.

    Primarily intended to be used by configuration providers to allow them to specify a path to a configuration
    file, or configuration override.
    &#34;&#34;&#34;
    self.arguments.append(Argument(*args, **kwargs))</code></pre>
</details>
</dd>
<dt id="incontext.InContext.add_command"><code class="name flex">
<span>def <span class="ident">add_command</span></span>(<span>self, name, function, help='')</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new command line command.</p>
<p>The callable, function, will be called with the <code>argparse.ArgumentParser</code> sub-parser instance for that command as
the first argument to allow the command to register any command-line arguments it requires. The command function
must return a new callable which will be called if the the command is selected from the command line.</p>
<p>@param name: The command identifier.
@type name: str
@param function: The function to be called to perform the registration.
@type function: callable
@param help: The help string that describes the command to be printed when the user passes the '&ndash;help' flag.
@type help: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_command(self, name, function, help=&#34;&#34;):
    &#34;&#34;&#34;
    Register a new command line command.

    The callable, function, will be called with the `argparse.ArgumentParser` sub-parser instance for that command as
    the first argument to allow the command to register any command-line arguments it requires. The command function
    must return a new callable which will be called if the the command is selected from the command line.

    @param name: The command identifier.
    @type name: str
    @param function: The function to be called to perform the registration.
    @type function: callable
    @param help: The help string that describes the command to be printed when the user passes the &#39;--help&#39; flag.
    @type help: str
    &#34;&#34;&#34;
    self._plugins.add_plugin(PLUGIN_TYPE_COMMAND, name, _CommandPlugin(name=name,
                                                                       help=help,
                                                                       callback=function,
                                                                       callback_type=CALLBACK_TYPE_SETUP))</code></pre>
</details>
</dd>
<dt id="incontext.InContext.add_configuration_provider"><code class="name flex">
<span>def <span class="ident">add_configuration_provider</span></span>(<span>self, name, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a named configuration provider.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_configuration_provider(self, name, function):
    &#34;&#34;&#34;
    Add a named configuration provider.
    &#34;&#34;&#34;
    self.configuration_providers[name] = function</code></pre>
</details>
</dd>
<dt id="incontext.InContext.add_handler"><code class="name flex">
<span>def <span class="ident">add_handler</span></span>(<span>self, name, function)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a new handler.</p>
<p>@param name: The handler identifier.
@type name: str
@param function: The function to be called.
@type function: callable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_handler(self, name, function):
    &#34;&#34;&#34;
    Register a new handler.

    @param name: The handler identifier.
    @type name: str
    @param function: The function to be called.
    @type function: callable
    &#34;&#34;&#34;
    if name in self.handlers:
        raise AssertionError(&#34;Handler &#39;%s&#39; is already defined.&#34; % name)
    self.handlers[name] = function</code></pre>
</details>
</dd>
<dt id="incontext.InContext.add_plugin"><code class="name flex">
<span>def <span class="ident">add_plugin</span></span>(<span>self, domain, name, plugin)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a plugin, <code>plugin</code>, named <code>name</code>, in the specified domain, <code>domain</code>.</p>
<p>This is the generic mechanism by which plugins are able to themselves add extension points to InContext. For
example, the image handling plugin makes use of this to allow other plugins to register custom transforms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_plugin(self, domain, name, plugin):
    &#34;&#34;&#34;
    Add a plugin, `plugin`, named `name`, in the specified domain, `domain`.

    This is the generic mechanism by which plugins are able to themselves add extension points to InContext. For
    example, the image handling plugin makes use of this to allow other plugins to register custom transforms.
    &#34;&#34;&#34;
    self._plugins.add_plugin(plugin_type=domain, name=name, plugin=plugin)</code></pre>
</details>
</dd>
<dt id="incontext.InContext.add_task"><code class="name flex">
<span>def <span class="ident">add_task</span></span>(<span>self, name, function)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_task(self, name, function):
    if name in self.tasks:
        raise AssertionError(&#34;Task &#39;%s&#39; is already defined.&#34; % name)
    self.tasks[name] = function</code></pre>
</details>
</dd>
<dt id="incontext.InContext.get_handler"><code class="name flex">
<span>def <span class="ident">get_handler</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the handler for a given name.</p>
<p>@param name: The handler identifier.
@type name: str</p>
<p>@return: Handler for a given name.
@rtype: callable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_handler(self, name):
    &#34;&#34;&#34;
    Return the handler for a given name.

    @param name: The handler identifier.
    @type name: str

    @return: Handler for a given name.
    @rtype: callable
    &#34;&#34;&#34;
    return self.handlers[name]</code></pre>
</details>
</dd>
<dt id="incontext.InContext.get_task"><code class="name flex">
<span>def <span class="ident">get_task</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the task associated with <code>name</code>.</p>
<p>Raises <code>KeyError</code> if no task has been registered with <code>name</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_task(self, name):
    &#34;&#34;&#34;
    Return the task associated with `name`.

    Raises `KeyError` if no task has been registered with `name`.
    &#34;&#34;&#34;
    return self.tasks[name]</code></pre>
</details>
</dd>
<dt id="incontext.InContext.load_plugins"><code class="name flex">
<span>def <span class="ident">load_plugins</span></span>(<span>self, directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Load and initialize the plugins in a given directory, adding them to the incontext instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_plugins(self, directory):
    &#34;&#34;&#34;
    Load and initialize the plugins in a given directory, adding them to the incontext instance.
    &#34;&#34;&#34;
    directory = os.path.abspath(directory)
    if directory in self._loaded_plugin_directories:
        return
    self._loaded_plugin_directories[directory] = True
    plugins = utils.load_plugins(directory)
    for plugin_name, plugin_instance in plugins.items():

        # Load the classic method-based plugins.
        if hasattr(plugin_instance, &#39;initialize_plugin&#39;):
            logging.debug(&#34;Initializing legacy plugin &#39;%s&#39;...&#34;, plugin_name)
            plugin_instance.initialize_plugin(self)

        # Load the decorator-based plugins by copying in their &#39;global&#39; state.
        if hasattr(plugin_instance, &#39;incontext&#39;):
            logging.debug(&#34;Initializing plugin &#39;%s&#39;...&#34;, plugin_name)
            self._plugins.extend(plugin_instance.incontext._PLUGINS)</code></pre>
</details>
</dd>
<dt id="incontext.InContext.parser"><code class="name flex">
<span>def <span class="ident">parser</span></span>(<span>self, add_subparsers=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a parser, configured with the currently loaded plugins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parser(self, add_subparsers=True):
    &#34;&#34;&#34;
    Return a parser, configured with the currently loaded plugins.
    &#34;&#34;&#34;
    # Create the argument parser.
    parser = argparse.ArgumentParser(prog=&#34;incontext&#34;, add_help=False, description=&#34;Generate website.&#34;)
    parser.add_argument(&#39;--help&#39;, &#39;-h&#39;, default=False, action=&#39;store_true&#39;, help=&#34;show this help message and exit&#34;)
    parser.add_argument(&#39;--site&#39;, &#39;-s&#39;, default=os.getcwd(), help=&#34;path to the root of the site&#34;)
    parser.add_argument(&#39;--verbose&#39;, &#39;-v&#39;, action=&#39;store_true&#39;, default=False, help=&#34;show verbose output&#34;)
    parser.add_argument(&#39;--volume&#39;, action=&#39;append&#39;, help=&#34;mount an additional volume in the Docker container&#34;)

    # Add the top-level arguments.
    for argument in self.arguments:
        parser.add_argument(*(argument.args), **(argument.kwargs))

    # Prepare the commands for running (if requested).
    if add_subparsers:
        subparsers = parser.add_subparsers(help=&#34;command to run&#34;)
        for command_plugin in self._plugins.plugins(PLUGIN_TYPE_COMMAND).values():
            subparser = subparsers.add_parser(command_plugin.name, help=command_plugin.help)
            fn = command_plugin.configure(self, subparser)
            subparser.set_defaults(fn=fn)

    return parser</code></pre>
</details>
</dd>
<dt id="incontext.InContext.plugin"><code class="name flex">
<span>def <span class="ident">plugin</span></span>(<span>self, domain, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the plugin <code>name</code> in the domain, <code>domain</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plugin(self, domain, name):
    &#34;&#34;&#34;
    Get the plugin `name` in the domain, `domain`.
    &#34;&#34;&#34;
    return self._plugins.plugin(plugin_type=domain, name=name)</code></pre>
</details>
</dd>
<dt id="incontext.InContext.plugins"><code class="name flex">
<span>def <span class="ident">plugins</span></span>(<span>self, domain)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary of all plugins in a specific domain, keyed by their name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plugins(self, domain):
    &#34;&#34;&#34;
    Return a dictionary of all plugins in a specific domain, keyed by their name.
    &#34;&#34;&#34;
    return self._plugins.plugins(plugin_type=domain)</code></pre>
</details>
</dd>
<dt id="incontext.InContext.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, args=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse the command line arguments and execute the requested command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, args=None):
    &#34;&#34;&#34;
    Parse the command line arguments and execute the requested command.
    &#34;&#34;&#34;

    # Parse the top-level arguments, ignoring unknown arguments.
    parser = self.parser(add_subparsers=False)
    options, unknown = parser.parse_known_args(args)

    # Check to see if there are any site-local plugins.
    plugins_directory = os.path.join(os.path.abspath(options.site), &#34;plugins&#34;)
    if os.path.exists(plugins_directory):
        logging.debug(&#34;Loading site plugins...&#34;)
        self.load_plugins(plugins_directory)

    # Re-parse the arguments, along with the sub-commands / sub-parsers.
    logging.debug(&#34;Re-processing arguments with sub-commands...&#34;)
    parser = self.parser()
    options = parser.parse_args(args)

    # Explicit handling of the help functionality.
    if options.help:
        parser.print_help()
        exit(1)

    # Handle the arguments, running the command if specified.
    for name, configuration_provider in self.configuration_providers.items():
        self.configuration.add(name, configuration_provider(self, options))
    if &#39;fn&#39; not in options:
        logging.error(&#34;No command specified.&#34;)
        exit(1)
    options.fn(options)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="incontext.Namespace"><code class="flex name class">
<span>class <span class="ident">Namespace</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Namespace:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="incontext.command" href="#incontext.command">command</a></code></li>
<li><code><a title="incontext.context_function" href="#incontext.context_function">context_function</a></code></li>
<li><code><a title="incontext.main" href="#incontext.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="incontext.Argument" href="#incontext.Argument">Argument</a></code></h4>
</li>
<li>
<h4><code><a title="incontext.Configuration" href="#incontext.Configuration">Configuration</a></code></h4>
<ul class="">
<li><code><a title="incontext.Configuration.add" href="#incontext.Configuration.add">add</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="incontext.InContext" href="#incontext.InContext">InContext</a></code></h4>
<ul class="">
<li><code><a title="incontext.InContext.add_argument" href="#incontext.InContext.add_argument">add_argument</a></code></li>
<li><code><a title="incontext.InContext.add_command" href="#incontext.InContext.add_command">add_command</a></code></li>
<li><code><a title="incontext.InContext.add_configuration_provider" href="#incontext.InContext.add_configuration_provider">add_configuration_provider</a></code></li>
<li><code><a title="incontext.InContext.add_handler" href="#incontext.InContext.add_handler">add_handler</a></code></li>
<li><code><a title="incontext.InContext.add_plugin" href="#incontext.InContext.add_plugin">add_plugin</a></code></li>
<li><code><a title="incontext.InContext.add_task" href="#incontext.InContext.add_task">add_task</a></code></li>
<li><code><a title="incontext.InContext.commands" href="#incontext.InContext.commands">commands</a></code></li>
<li><code><a title="incontext.InContext.context_functions" href="#incontext.InContext.context_functions">context_functions</a></code></li>
<li><code><a title="incontext.InContext.get_handler" href="#incontext.InContext.get_handler">get_handler</a></code></li>
<li><code><a title="incontext.InContext.get_task" href="#incontext.InContext.get_task">get_task</a></code></li>
<li><code><a title="incontext.InContext.load_plugins" href="#incontext.InContext.load_plugins">load_plugins</a></code></li>
<li><code><a title="incontext.InContext.parser" href="#incontext.InContext.parser">parser</a></code></li>
<li><code><a title="incontext.InContext.plugin" href="#incontext.InContext.plugin">plugin</a></code></li>
<li><code><a title="incontext.InContext.plugins" href="#incontext.InContext.plugins">plugins</a></code></li>
<li><code><a title="incontext.InContext.run" href="#incontext.InContext.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="incontext.Namespace" href="#incontext.Namespace">Namespace</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>